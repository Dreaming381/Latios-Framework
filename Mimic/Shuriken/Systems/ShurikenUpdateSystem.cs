#if false
using Latios.Kinemation;
using Latios.LifeFX;
using Latios.Mimic.Shuriken.Internal;
using Latios.Transforms.Abstract;
using Unity.Burst;
using Unity.Burst.Intrinsics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Mathematics;
using UnityEngine;

using static Unity.Entities.SystemAPI;

namespace Latios.Mimic.Shuriken.Systems
{
    /* TODOS:
       1.  Add resimulation functionality (complete reset to a specific point in time)
       2.  Add support for sub-emitters
       3.  Store or resimulate particle rotations generated by shape module.  All other modules assume rotation recomputation per frame, and shape module sets it only once on emission.  This stableSeed should be stored or shape module should resimulate rotation every frame.
       4.  Position values cannot be resimulated, because they are the aggregation of velocity changes per frame.  Can we find a way to separate velocity position accumulation and pure simulation position?  If so, we can simplify logic and perhaps only resimulate velocity and accumulations for a simulation request at a specific time.
     */
    [DisableAutoCreation]
    [BurstCompile]
    public partial struct ShurikenUpdateSystem : ISystem
    {
        private WorldTransformReadOnlyAspect.TypeHandle m_worldTransformHandle;
        private EntityQuery m_query;
        private float m_previousDeltaTime;
        private float m_previousUnscaledDeltaTime;

        public void OnCreate(ref SystemState state)
        {
            var builder = new EntityQueryBuilder(Allocator.Temp)
                          .WithAllRW<ShurikenParticleSystemData>();

            m_query = builder.Build(ref state);
            builder.Dispose();

            m_previousDeltaTime = m_previousUnscaledDeltaTime = 8f * math.EPSILON;
            state.EntityManager.AddComponentData(state.SystemHandle, new SystemRng("ShurikenUpdateSystem"));

            m_worldTransformHandle = new WorldTransformReadOnlyAspect.TypeHandle(ref state);
        }

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            m_worldTransformHandle.Update(ref state);
            var deltaTime         = state.WorldUnmanaged.Time.DeltaTime;
            var unscaledDeltaTime = UnityEngine.Time.unscaledDeltaTime;

            var job = new ShurikenUpdateJob
            {
                systemRng                             = state.EntityManager.GetComponentDataRW<SystemRng>(state.SystemHandle).ValueRW.Shuffle(),
                deltaTime                             = deltaTime,
                unscaledDeltaTime                     = unscaledDeltaTime,
                previousDeltaTime                     = m_previousDeltaTime,
                previousUnscaledDeltaTime             = m_previousUnscaledDeltaTime,
                transformHandle                       = m_worldTransformHandle,
                particleSystemHandle                  = GetComponentTypeHandle<ShurikenParticleSystemData>(false),
                mainModuleHandle                      = GetComponentTypeHandle<ShurikenMainModuleOverride>(true),
                emissionModuleHandle                  = GetComponentTypeHandle<ShurikenEmissionModuleOverride>(true),
                emissionBurstHandle                   = GetBufferTypeHandle<EmissionBurst>(true),
                shapeModuleHandle                     = GetComponentTypeHandle<ShurikenShapeModuleOverride>(true),
                velocityOverLifetimeModuleHandle      = GetComponentTypeHandle<ShurikenVelocityOverLifetimeModuleOverride>(true),
                limitVelocityOverLifetimeModuleHandle = GetComponentTypeHandle<ShurikenLimitVelocityOverLifetimeModuleOverride>(true),
                inheritVelocityModuleHandle           = GetComponentTypeHandle<ShurikenInheritVelocityModuleOverride>(true),
                lifetimeByEmitterSpeedModuleHandle    = GetComponentTypeHandle<ShurikenLifetimeByEmitterSpeedModuleOverride>(true),
                forceOverLifetimeModuleHandle         = GetComponentTypeHandle<ShurikenForceOverLifetimeModuleOverride>(true),
                colorOverLifetimeModuleHandle         = GetComponentTypeHandle<ShurikenColorOverLifetimeModuleOverride>(true),
                colorBySpeedModuleHandle              = GetComponentTypeHandle<ShurikenColorBySpeedModuleOverride>(true),
                sizeOverLifetimeModuleHandle          = GetComponentTypeHandle<ShurikenSizeOverLifetimeModuleOverride>(true),
                sizeBySpeedModuleHandle               = GetComponentTypeHandle<ShurikenSizeBySpeedModuleOverride>(true),
                rotationOverLifetimeModuleHandle      = GetComponentTypeHandle<ShurikenRotationOverLifetimeModuleOverride>(true),
                rotationBySpeedModuleHandle           = GetComponentTypeHandle<ShurikenRotationBySpeedModuleOverride>(true),
                //externalForcesModuleHandle = GetComponentTypeHandle<ShurikenExternalForcesModuleOverride>(true),
                noiseModuleHandle                  = GetComponentTypeHandle<ShurikenNoiseModuleOverride>(true),
                particleSeedHandle                 = GetBufferTypeHandle<ParticleSeed>(false),
                particleCenterHandle               = GetBufferTypeHandle<ParticleCenter>(false),
                particleRotation3dHandle           = GetBufferTypeHandle<ParticleRotation3d>(false),
                particleRotationSpeedHandle        = GetBufferTypeHandle<ParticleRotationSpeed>(false),
                particleScale3dHandle              = GetBufferTypeHandle<ParticleScale3d>(false),
                particleColorHandle                = GetBufferTypeHandle<ParticleColor>(false),
                particleVelocityHandle             = GetBufferTypeHandle<ParticleVelocity>(false),
                particleAgePercentHandle           = GetBufferTypeHandle<ParticleAgeFraction>(false),
                particleInverseStartLifetimeHandle = GetBufferTypeHandle<ParticleInverseStartLifetime>(false)
            };

            state.Dependency            = job.ScheduleParallel(m_query, state.Dependency);
            m_previousDeltaTime         = deltaTime;
            m_previousUnscaledDeltaTime = unscaledDeltaTime;
        }
        public void OnDestroy(ref SystemState state)
        {
        }

        [BurstCompile]
        private struct ShurikenUpdateJob : IJobChunk
        {
            public SystemRng systemRng;
            //TODO:  Get this from the world
            public float2 physics2dGravity;
            public float3 physics3dGravity;
            public WorldTransformReadOnlyAspect.TypeHandle transformHandle;
            public ComponentTypeHandle<ShurikenParticleSystemData> particleSystemHandle;
            public float deltaTime;
            public float unscaledDeltaTime;
            public float previousDeltaTime;
            public float previousUnscaledDeltaTime;

            //Modules
            public ComponentTypeHandle<ShurikenMainModuleOverride> mainModuleHandle;
            public ComponentTypeHandle<ShurikenEmissionModuleOverride> emissionModuleHandle;
            public BufferTypeHandle<EmissionBurst> emissionBurstHandle;
            public ComponentTypeHandle<ShurikenShapeModuleOverride> shapeModuleHandle;
            public ComponentTypeHandle<ShurikenVelocityOverLifetimeModuleOverride> velocityOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenLimitVelocityOverLifetimeModuleOverride> limitVelocityOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenInheritVelocityModuleOverride> inheritVelocityModuleHandle;
            public ComponentTypeHandle<ShurikenLifetimeByEmitterSpeedModuleOverride> lifetimeByEmitterSpeedModuleHandle;
            public ComponentTypeHandle<ShurikenForceOverLifetimeModuleOverride> forceOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenColorOverLifetimeModuleOverride> colorOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenColorBySpeedModuleOverride> colorBySpeedModuleHandle;
            public ComponentTypeHandle<ShurikenSizeOverLifetimeModuleOverride> sizeOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenSizeBySpeedModuleOverride> sizeBySpeedModuleHandle;
            public ComponentTypeHandle<ShurikenRotationOverLifetimeModuleOverride> rotationOverLifetimeModuleHandle;
            public ComponentTypeHandle<ShurikenRotationBySpeedModuleOverride> rotationBySpeedModuleHandle;
            //public ComponentTypeHandle<ShurikenExternalForcesModuleOverride> externalForcesModuleHandle;
            public ComponentTypeHandle<ShurikenNoiseModuleOverride> noiseModuleHandle;
            // public ComponentTypeHandle<ShurikenCollisionModuleOverride> collisionModuleHandle;
            // public ComponentTypeHandle<ShurikenTriggerModuleOverride> triggerModuleHandle;
            // public ComponentTypeHandle<ShurikenSubEmittersModuleOverride> subEmittersModuleHandle;
            // public ComponentTypeHandle<ShurikenTextureSheetAnimationModuleOverride> textureSheetAnimationModuleHandle;
            // public ComponentTypeHandle<ShurikenLightsModuleOverride> lightsModuleHandle;
            // public ComponentTypeHandle<ShurikenTrailModuleOverride> trailsModuleHandle;

            //Particle Attributes
            public BufferTypeHandle<ParticleSeed> particleSeedHandle;
            public BufferTypeHandle<ParticleCenter> particleCenterHandle;
            public BufferTypeHandle<ParticleRotation> particleRotationHandle;
            public BufferTypeHandle<ParticleRotation3d> particleRotation3dHandle;
            public BufferTypeHandle<ParticleRotationSpeed> particleRotationSpeedHandle;
            public BufferTypeHandle<ParticleScale> particleScaleHandle;
            public BufferTypeHandle<ParticleScale3d> particleScale3dHandle;
            public BufferTypeHandle<ParticleColor> particleColorHandle;
            public BufferTypeHandle<ParticleVelocity> particleVelocityHandle;
            public BufferTypeHandle<ParticleAgeFraction> particleAgePercentHandle;
            public BufferTypeHandle<ParticleInverseStartLifetime> particleInverseStartLifetimeHandle;

            /*
             * TODO:  Consider migrating this to c++.
             * Justification - We are not parallelizing the particle updates, just the systems.
             * The update calculation requirements are hefty for some modules, and the
             * resimulation requirements will be taxing for the entire system.  C++ will offer
             * the best possible single-threaded performance.
             */
            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                var particleSystems                       = chunk.GetNativeArray(ref particleSystemHandle);
                var transforms                            = transformHandle.Resolve(chunk);
                var mainModules                           = chunk.GetNativeArray(ref mainModuleHandle);
                var emissionModules                       = chunk.GetNativeArray(ref emissionModuleHandle);
                var emissionBurstsAccessor                = chunk.GetBufferAccessor(ref emissionBurstHandle);
                var shapeModules                          = chunk.GetNativeArray(ref shapeModuleHandle);
                var velocityOverLifetimeModules           = chunk.GetNativeArray(ref velocityOverLifetimeModuleHandle);
                var limitVelocityOverLifetimeModules      = chunk.GetNativeArray(ref limitVelocityOverLifetimeModuleHandle);
                var inheritVelocityModules                = chunk.GetNativeArray(ref inheritVelocityModuleHandle);
                var lifetimeByEmitterSpeedModules         = chunk.GetNativeArray(ref lifetimeByEmitterSpeedModuleHandle);
                var forceOverLifetimeModules              = chunk.GetNativeArray(ref forceOverLifetimeModuleHandle);
                var colorOverLifetimeModules              = chunk.GetNativeArray(ref colorOverLifetimeModuleHandle);
                var colorBySpeedModules                   = chunk.GetNativeArray(ref colorBySpeedModuleHandle);
                var sizeOverLifetimeModules               = chunk.GetNativeArray(ref sizeOverLifetimeModuleHandle);
                var sizeBySpeedModules                    = chunk.GetNativeArray(ref sizeBySpeedModuleHandle);
                var rotationOverLifetimeModules           = chunk.GetNativeArray(ref rotationOverLifetimeModuleHandle);
                var rotationBySpeedModules                = chunk.GetNativeArray(ref rotationBySpeedModuleHandle);
                var noiseModules                          = chunk.GetNativeArray(ref noiseModuleHandle);
                var particleSeedsAccessor                 = chunk.GetBufferAccessor(ref particleSeedHandle);
                var particleCentersAccessor               = chunk.GetBufferAccessor(ref particleCenterHandle);
                var particleRotationsAccessor             = chunk.GetBufferAccessor(ref particleRotationHandle);
                var particleRotations3dAccessor           = chunk.GetBufferAccessor(ref particleRotation3dHandle);
                var particleRotationSpeedsAccessor        = chunk.GetBufferAccessor(ref particleRotationSpeedHandle);
                var particleScalesAccessor                = chunk.GetBufferAccessor(ref particleScaleHandle);
                var particleScales3dAccessor              = chunk.GetBufferAccessor(ref particleScale3dHandle);
                var particleColorsAccessor                = chunk.GetBufferAccessor(ref particleColorHandle);
                var particleVelocitiesAccessor            = chunk.GetBufferAccessor(ref particleVelocityHandle);
                var particleAgePercentsAccessor           = chunk.GetBufferAccessor(ref particleAgePercentHandle);
                var particleInverseStartLifetimesAccessor = chunk.GetBufferAccessor(ref particleInverseStartLifetimeHandle);

                for (int entityIndexInChunk = 0; entityIndexInChunk < chunk.Count; entityIndexInChunk++)
                {
                    var particleSystem = particleSystems[entityIndexInChunk];

                    var transform = transforms[entityIndexInChunk];

                    var particleSeeds                 = particleSeedsAccessor[entityIndexInChunk];
                    var particleCenters               = particleCentersAccessor[entityIndexInChunk];
                    var particleAgePercents           = particleAgePercentsAccessor[entityIndexInChunk];
                    var particleInverseStartLifetimes = particleInverseStartLifetimesAccessor[entityIndexInChunk];
                    var particleRotationSpeeds        = particleRotationSpeedsAccessor[entityIndexInChunk];

                    //TODO:  Implement separate axis setting for scale and rotation
                    //Optional buffers determined by "separate axes" setting
                    bool hasRotation3d     = false;
                    DynamicBuffer<ParticleRotation> particleRotations = default;
                    if (particleRotationsAccessor.Length > 0)
                    {
                        particleRotations = particleRotationsAccessor[entityIndexInChunk];
                    }

                    DynamicBuffer<ParticleRotation3d> particleRotations3d = default;
                    if (particleRotations3dAccessor.Length > 0)
                    {
                        particleRotations3d = particleRotations3dAccessor[entityIndexInChunk];
                        hasRotation3d       = true;
                    }

                    bool hasScale3d     = false;
                    DynamicBuffer<ParticleScale> particleScales = default;
                    if (particleScalesAccessor.Length > 0)
                    {
                        particleScales = particleScalesAccessor[entityIndexInChunk];
                    }

                    DynamicBuffer<ParticleScale3d> particleScales3d = default;
                    if (particleScales3dAccessor.Length > 0)
                    {
                        particleScales3d = particleScales3dAccessor[entityIndexInChunk];
                        hasScale3d       = true;
                    }

                    var hasColor       = false;
                    DynamicBuffer<ParticleColor> particleColors = default;
                    if (particleColorsAccessor.Length > 0)
                    {
                        particleColors = particleColorsAccessor[entityIndexInChunk];
                        hasColor       = true;
                    }

                    var hasVelocity        = false;
                    DynamicBuffer<ParticleVelocity> particleVelocities = default;
                    if (particleVelocitiesAccessor.Length > 0)
                    {
                        particleVelocities = particleVelocitiesAccessor[entityIndexInChunk];
                        hasVelocity        = true;
                    }

                    //Get the main module
                    ShurikenMainModule mainModule;
                    ref ParameterClip mainModuleClip = ref GetModuleAndClip(in chunk,
                                                                            entityIndexInChunk,
                                                                            in mainModules,
                                                                            in particleSystem.Modules.Value.mainModule,
                                                                            ref particleSystem.Modules.Value.sampledClips,
                                                                            ShurikenMainModule.clipIndex,
                                                                            out mainModule);

                    if (!particleSystem.isPaused)
                    {
                        //Destroy particles that have aged out
                        for (int i = 0; i < particleAgePercents.Length; i++)
                        {
                            if (particleAgePercents[i].fraction >= 1f)
                            {
                                RemoveParticle(i, ref particleSeeds, ref particleCenters, hasRotation3d,
                                               ref particleRotations, ref particleRotations3d, ref particleRotationSpeeds,
                                               hasScale3d, ref particleScales, ref particleScales3d, hasColor,
                                               ref particleColors, hasVelocity, ref particleVelocities,
                                               ref particleAgePercents, ref particleInverseStartLifetimes);
                            }
                        }

                        bool isDelayed;
                        float simulationDeltaTime;
                        float previousSimulationDeltaTime;

                        ShurikenInternalUtilities.DoMainModule(ref mainModuleClip, ref particleSystem, mainModule,
                                                               physics2dGravity, physics3dGravity, deltaTime, unscaledDeltaTime, previousDeltaTime, previousUnscaledDeltaTime,
                                                               in particleSeeds, in particleInverseStartLifetimes, ref particleAgePercents,
                                                               hasRotation3d, ref particleRotations, ref particleRotations3d,
                                                               hasScale3d, ref particleScales, ref particleScales3d,
                                                               hasVelocity, ref particleVelocities, hasColor, ref particleColors,
                                                               out isDelayed, out simulationDeltaTime, out previousSimulationDeltaTime);

                        if (particleSystem.isPlaying && !isDelayed)
                        {
                            var emitterVelocity = transform.position - particleSystem.previousPosition;

                            #region Emission Module

                            //Get distance traveled
                            var distanceTraveledDelta = math.length(transform.position - particleSystem.previousPosition);
                            int newParticleCount;
                            ShurikenEmissionModule emissionModule;
                            ParameterClip emissionModuleClip;
                            NativeArray<EmissionBurst> emissionBursts;
                            if (chunk.HasChunkComponent<ShurikenEmissionModuleOverride>())
                            {
                                emissionModule     = emissionModules[entityIndexInChunk].module;
                                emissionModuleClip = emissionModules[entityIndexInChunk].clip.Value;
                                emissionBursts     = emissionBurstsAccessor[entityIndexInChunk].AsNativeArray();
                            }
                            else
                            {
                                emissionModule     = particleSystem.Modules.Value.emissionModule;
                                emissionModuleClip = particleSystem.Modules.Value.sampledClips.clips[ShurikenEmissionModule.clipIndex];
                                ref var emissionBurstsBlobArray = ref particleSystem.Modules.Value.emissionBursts;

                                unsafe
                                {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                                    AtomicSafetyHandle safety = AtomicSafetyHandle.GetTempMemoryHandle();
                                    AtomicSafetyHandle.CheckGetSecondaryDataPointerAndThrow(safety);
#endif
                                    emissionBursts =
                                        NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<EmissionBurst>(
                                            (byte*)emissionBurstsBlobArray.GetUnsafePtr(),
                                            emissionBurstsBlobArray.Length, Allocator.None);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                                    AtomicSafetyHandle.CheckWriteAndBumpSecondaryVersion(safety);
                                    AtomicSafetyHandle.UseSecondaryVersion(ref safety);
                                    AtomicSafetyHandle.SetAllowSecondaryVersionWriting(safety, false);
                                    NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref emissionBursts, safety);
#endif
                                }
                            }

                            ShurikenInternalUtilities.DoEmissionModule(ref emissionModuleClip, particleSystem, emissionModule, emissionBursts, simulationDeltaTime,
                                                                       distanceTraveledDelta, out newParticleCount);
                            #endregion

                            //Create newly emitted particles
                            for (int i = 0; i < newParticleCount; i++)
                            {
                                ShurikenInternalUtilities.CreateParticleData(ref mainModuleClip, systemRng.NextUInt(), particleSystem, mainModule, ref particleSeeds,
                                                                             ref particleCenters, hasRotation3d, ref particleRotations, ref particleRotations3d,
                                                                             ref particleRotationSpeeds, hasScale3d, ref particleScales, ref particleScales3d,
                                                                             hasColor, ref particleColors, hasVelocity, ref particleVelocities, ref particleAgePercents,
                                                                             ref particleInverseStartLifetimes);
                            }

                            //Destroy old particles if necessary
                            for (int i = 0; i < particleAgePercents.Length - mainModule.maxParticles; i++)
                            {
                                RemoveParticle(i, ref particleSeeds, ref particleCenters, hasRotation3d,
                                               ref particleRotations, ref particleRotations3d, ref particleRotationSpeeds,
                                               hasScale3d, ref particleScales, ref particleScales3d, hasColor,
                                               ref particleColors, hasVelocity, ref particleVelocities,
                                               ref particleAgePercents, ref particleInverseStartLifetimes);
                            }

                            #region Shape Module

                            ShurikenShapeModule shapeModule;
                            ref ParameterClip shapeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                     entityIndexInChunk,
                                                                                     in shapeModules,
                                                                                     in particleSystem.Modules.Value.shapeModule,
                                                                                     ref particleSystem.Modules.Value.sampledClips,
                                                                                     ShurikenShapeModule.clipIndex,
                                                                                     out shapeModule);

                            ShurikenInternalUtilities.DoShapeModule(ref shapeModuleClip,
                                                                    particleSystem,
                                                                    shapeModule,
                                                                    newParticleCount,
                                                                    particleSeeds,
                                                                    particleAgePercents,
                                                                    particleInverseStartLifetimes,
                                                                    ref particleCenters,
                                                                    hasRotation3d,
                                                                    ref particleRotations,
                                                                    ref particleRotations3d,
                                                                    hasVelocity,
                                                                    ref particleVelocities);

                            #endregion

                            if (hasVelocity)
                            {
                                #region Velocity Over Lifetime Module

                                ShurikenVelocityOverLifetimeModule velocityOverLifetimeModule;
                                ref ParameterClip velocityOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                        entityIndexInChunk,
                                                                                                        in velocityOverLifetimeModules,
                                                                                                        in particleSystem.Modules.Value.velocityOverLifetimeModule,
                                                                                                        ref particleSystem.Modules.Value.sampledClips,
                                                                                                        ShurikenVelocityOverLifetimeModule.clipIndex,
                                                                                                        out velocityOverLifetimeModule);

                                ShurikenInternalUtilities.DoVelocityOverLifetimeModule(
                                    ref velocityOverLifetimeModuleClip, particleSystem, velocityOverLifetimeModule,
                                    transform.rotation, particleSeeds, particleCenters, ref particleVelocities);

                                #endregion

                                #region Limit Velocity Over Lifetime Module

                                ShurikenLimitVelocityOverLifetimeModule limitVelocityOverLifetimeModule;
                                ref ParameterClip limitVelocityOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                             entityIndexInChunk,
                                                                                                             in limitVelocityOverLifetimeModules,
                                                                                                             in particleSystem.Modules.Value.limitVelocityOverLifetimeModule,
                                                                                                             ref particleSystem.Modules.Value.sampledClips,
                                                                                                             ShurikenLimitVelocityOverLifetimeModule.clipIndex,
                                                                                                             out limitVelocityOverLifetimeModule);

                                ShurikenInternalUtilities.DoLimitVelocityOverLifetimeModule(ref limitVelocityOverLifetimeModuleClip,
                                                                                            particleSystem,
                                                                                            limitVelocityOverLifetimeModule,
                                                                                            transform.rotation,
                                                                                            particleSeeds,
                                                                                            particleAgePercents,
                                                                                            particleScales3d,
                                                                                            ref particleVelocities);

                                #endregion

                                #region Inherit Velocity Module
                                ShurikenInheritVelocityModule inheritVelocityModule;
                                ref ParameterClip inheritVelocityModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                   entityIndexInChunk,
                                                                                                   in inheritVelocityModules,
                                                                                                   in particleSystem.Modules.Value.inheritVelocityModule,
                                                                                                   ref particleSystem.Modules.Value.sampledClips,
                                                                                                   ShurikenInheritVelocityModule.clipIndex,
                                                                                                   out inheritVelocityModule);

                                ShurikenInternalUtilities.DoInheritVelocityModule(ref inheritVelocityModuleClip, particleSystem, inheritVelocityModule, emitterVelocity,
                                                                                  particleSeeds, ref particleVelocities);
                                #endregion
                            }

                            #region Lifetime By Emitter Speed Module
                            ShurikenLifetimeByEmitterSpeedModule lifetimeByEmitterSpeedModule;
                            ref ParameterClip lifetimeByEmitterSpeedModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                      entityIndexInChunk,
                                                                                                      in lifetimeByEmitterSpeedModules,
                                                                                                      in particleSystem.Modules.Value.lifetimeByEmitterSpeedModule,
                                                                                                      ref particleSystem.Modules.Value.sampledClips,
                                                                                                      ShurikenLifetimeByEmitterSpeedModule.clipIndex,
                                                                                                      out lifetimeByEmitterSpeedModule);

                            ShurikenInternalUtilities.DoLifetimeByEmitterSpeedModule(ref lifetimeByEmitterSpeedModuleClip,
                                                                                     lifetimeByEmitterSpeedModule,
                                                                                     math.length(emitterVelocity),
                                                                                     newParticleCount,
                                                                                     particleSeeds,
                                                                                     ref particleAgePercents,
                                                                                     ref particleInverseStartLifetimes);
                            #endregion

                            if (hasVelocity)
                            {
                                #region Force Over Lifetime Module

                                ShurikenForceOverLifetimeModule forceOverLifetimeModule;
                                ref ParameterClip forceOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                     entityIndexInChunk,
                                                                                                     in forceOverLifetimeModules,
                                                                                                     in particleSystem.Modules.Value.forceOverLifetimeModule,
                                                                                                     ref particleSystem.Modules.Value.sampledClips,
                                                                                                     ShurikenForceOverLifetimeModule.clipIndex,
                                                                                                     out forceOverLifetimeModule);

                                ShurikenInternalUtilities.DoForceOverLifetimeModule(ref forceOverLifetimeModuleClip,
                                                                                    forceOverLifetimeModule, transform.rotation,
                                                                                    particleSeeds, particleAgePercents, ref particleVelocities);

                                #endregion
                            }

                            if (hasColor)
                            {
                                #region Color Over Lifetime Module

                                ShurikenColorOverLifetimeModule colorOverLifetimeModule;
                                ref ParameterClip colorOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                     entityIndexInChunk,
                                                                                                     in colorOverLifetimeModules,
                                                                                                     in particleSystem.Modules.Value.colorOverLifetimeModule,
                                                                                                     ref particleSystem.Modules.Value.sampledClips,
                                                                                                     ShurikenColorOverLifetimeModule.clipIndex,
                                                                                                     out colorOverLifetimeModule);

                                ShurikenInternalUtilities.DoColorOverLifetimeModule(ref colorOverLifetimeModuleClip,
                                                                                    colorOverLifetimeModule, particleSeeds,
                                                                                    particleAgePercents, ref particleColors);

                                #endregion

                                #region ColorBySpeed Module

                                ShurikenColorBySpeedModule colorBySpeedModule;
                                ref ParameterClip colorBySpeedModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                entityIndexInChunk,
                                                                                                in colorBySpeedModules,
                                                                                                in particleSystem.Modules.Value.colorBySpeedModule,
                                                                                                ref particleSystem.Modules.Value.sampledClips,
                                                                                                ShurikenColorBySpeedModule.clipIndex,
                                                                                                out colorBySpeedModule);

                                ShurikenInternalUtilities.DoColorBySpeedModule(ref colorBySpeedModuleClip,
                                                                               colorBySpeedModule, particleSeeds, particleVelocities,
                                                                               ref particleColors);

                                #endregion
                            }

                            #region Size Over Lifetime Module
                            ShurikenSizeOverLifetimeModule sizeOverLifetimeModule;
                            ref ParameterClip sizeOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                entityIndexInChunk,
                                                                                                in sizeOverLifetimeModules,
                                                                                                in particleSystem.Modules.Value.sizeOverLifetimeModule,
                                                                                                ref particleSystem.Modules.Value.sampledClips,
                                                                                                ShurikenSizeOverLifetimeModule.clipIndex,
                                                                                                out sizeOverLifetimeModule);

                            ShurikenInternalUtilities.DoSizeOverLifetimeModule(ref sizeOverLifetimeModuleClip, sizeOverLifetimeModule, particleSeeds,
                                                                               particleAgePercents, ref particleScales, ref particleScales3d);
                            #endregion

                            #region SizeBySpeed Module
                            ShurikenSizeBySpeedModule sizeBySpeedModule;
                            ref ParameterClip sizeBySpeedModuleClip = ref GetModuleAndClip(in chunk,
                                                                                           entityIndexInChunk,
                                                                                           in sizeBySpeedModules,
                                                                                           in particleSystem.Modules.Value.sizeBySpeedModule,
                                                                                           ref particleSystem.Modules.Value.sampledClips,
                                                                                           ShurikenSizeBySpeedModule.clipIndex,
                                                                                           out sizeBySpeedModule);

                            ShurikenInternalUtilities.DoSizeBySpeedModule(ref sizeBySpeedModuleClip, sizeBySpeedModule, particleSeeds, particleVelocities,
                                                                          ref particleScales, ref particleScales3d);
                            #endregion

                            #region Rotation Over Lifetime Module
                            ShurikenRotationOverLifetimeModule rotationOverLifetimeModule;
                            ref ParameterClip rotationOverLifetimeModuleClip = ref GetModuleAndClip(in chunk,
                                                                                                    entityIndexInChunk,
                                                                                                    in rotationOverLifetimeModules,
                                                                                                    in particleSystem.Modules.Value.rotationOverLifetimeModule,
                                                                                                    ref particleSystem.Modules.Value.sampledClips,
                                                                                                    ShurikenRotationOverLifetimeModule.clipIndex,
                                                                                                    out rotationOverLifetimeModule);

                            ShurikenInternalUtilities.DoRotationOverLifetimeModule(ref rotationOverLifetimeModuleClip, rotationOverLifetimeModule, particleSeeds,
                                                                                   particleAgePercents, ref particleRotations, ref particleRotations3d);
                            #endregion

                            #region RotationBySpeed Module
                            ShurikenRotationBySpeedModule rotationBySpeedModule;
                            ref ParameterClip rotationBySpeedModuleClip = ref GetModuleAndClip(in chunk,
                                                                                               entityIndexInChunk,
                                                                                               in rotationBySpeedModules,
                                                                                               in particleSystem.Modules.Value.rotationBySpeedModule,
                                                                                               ref particleSystem.Modules.Value.sampledClips,
                                                                                               ShurikenRotationBySpeedModule.clipIndex,
                                                                                               out rotationBySpeedModule);

                            ShurikenInternalUtilities.DoRotationBySpeedModule(ref rotationBySpeedModuleClip, rotationBySpeedModule, particleSeeds,
                                                                              particleVelocities, ref particleRotations, ref particleRotations3d);
                            #endregion

                            #region Noise Module
                            ShurikenNoiseModule noiseModule;
                            ref ParameterClip noiseModuleClip = ref GetModuleAndClip(in chunk,
                                                                                     entityIndexInChunk,
                                                                                     in noiseModules,
                                                                                     in particleSystem.Modules.Value.noiseModule,
                                                                                     ref particleSystem.Modules.Value.sampledClips,
                                                                                     ShurikenNoiseModule.clipIndex,
                                                                                     out noiseModule);
                            ShurikenInternalUtilities.DoNoiseModule(ref noiseModuleClip,
                                                                    noiseModule,
                                                                    previousSimulationDeltaTime,
                                                                    particleSeeds,
                                                                    particleAgePercents,
                                                                    particleInverseStartLifetimes,
                                                                    ref particleCenters,
                                                                    hasRotation3d,
                                                                    ref particleRotations,
                                                                    ref particleRotations3d,
                                                                    hasScale3d,
                                                                    ref particleScales,
                                                                    ref particleScales3d);

                            #endregion

                            //Move particles according to velocity
                            if (hasVelocity)
                            {
                                for (int i = 0; i < particleCenters.Length; i++)
                                {
                                    var particleCenter = particleCenters[i];
                                    particleCenter.center += particleVelocities[i].velocity * simulationDeltaTime;
                                    particleCenters[i]     = particleCenter;
                                }
                            }
                            //Update system state
                            particleSystem.distanceTraveled += distanceTraveledDelta;
                            particleSystem.previousPosition  = transform.position;
                            particleSystem.previousFrameTime = particleSystem.time;
                            particleSystem.time             += simulationDeltaTime;
                            particleSystem.totalTime        += simulationDeltaTime;
                        }
                    }

                    //Perform stop action
                    if (particleSystem.isStopped)
                    {
                        particleSystem.isPlaying        = false;
                        particleSystem.isPaused         = false;
                        particleSystem.time             = 0f;
                        particleSystem.totalTime        = 0f;
                        particleSystem.delayTime        = 0f;
                        particleSystem.distanceTraveled = 0f;
                        switch (mainModule.stopAction)
                        {
                            case ParticleSystemStopAction.None:
                                break;
                            case ParticleSystemStopAction.Disable:
                                //TODO:  ShurikenParticleSystemData as enableable?
                                break;
                            case ParticleSystemStopAction.Destroy:
                                //TODO:  Perhaps another enableable component that is disabled by default, and picked up by a system with ecb.
                                break;
                            case ParticleSystemStopAction.Callback:
                                //TODO:  Can we support this?
                                break;
                        }
                    }

                    particleSystems[entityIndexInChunk] = particleSystem;
                }
            }

            private void RemoveParticle(
                int particleIndex,
                ref DynamicBuffer<ParticleSeed>                 particleSeeds,
                ref DynamicBuffer<ParticleCenter>               particleCenters,
                bool hasRotation3d,
                ref DynamicBuffer<ParticleRotation>             particleRotations,
                ref DynamicBuffer<ParticleRotation3d>           particleRotations3d,
                ref DynamicBuffer<ParticleRotationSpeed>        particleRotationSpeeds,
                bool hasScale3d,
                ref DynamicBuffer<ParticleScale>                particleScales,
                ref DynamicBuffer<ParticleScale3d>              particleScales3d,
                bool hasColor,
                ref DynamicBuffer<ParticleColor>                particleColors,
                bool hasVelocity,
                ref DynamicBuffer<ParticleVelocity>             particleVelocities,
                ref DynamicBuffer<ParticleAgeFraction>          particleAgePercents,
                ref DynamicBuffer<ParticleInverseStartLifetime> particleInverseStartLifetimes)
            {
                particleSeeds.RemoveAtSwapBack(particleIndex);
                particleCenters.RemoveAtSwapBack(particleIndex);
                if (hasRotation3d)
                {
                    particleRotations3d.RemoveAtSwapBack(particleIndex);
                }
                else
                {
                    particleRotations.RemoveAtSwapBack(particleIndex);
                }
                particleRotationSpeeds.RemoveAtSwapBack(particleIndex);
                if (hasScale3d)
                {
                    particleScales3d.RemoveAtSwapBack(particleIndex);
                }
                else
                {
                    particleScales.RemoveAtSwapBack(particleIndex);
                }
                if (hasColor)
                {
                    particleColors.RemoveAtSwapBack(particleIndex);
                }
                if (hasVelocity)
                {
                    particleVelocities.RemoveAtSwapBack(particleIndex);
                }
                particleAgePercents.RemoveAtSwapBack(particleIndex);
                particleInverseStartLifetimes.RemoveAtSwapBack(particleIndex);
            }

            private ref ParameterClip GetModuleAndClip<T, T2>(in ArchetypeChunk chunk,
                                                              int entityIndexInChunk,
                                                              in NativeArray<T2>       components,
                                                              in T defaultModule,
                                                              ref ParameterClipSetBlob defaultParameterClips,
                                                              int defaultClipIndex,
                                                              out T resolvedModule)
                where T : unmanaged
                where T2 : unmanaged, IComponentData, IShurikenModuleComponent<T>
            {
                if (chunk.HasChunkComponent<T2>())
                {
                    resolvedModule = components[entityIndexInChunk].module;
                    return ref components[entityIndexInChunk].clip.Value;;
                }
                else
                {
                    resolvedModule = defaultModule;
                    return ref defaultParameterClips.clips[defaultClipIndex];
                }
            }
        }
    }
}
#endif

