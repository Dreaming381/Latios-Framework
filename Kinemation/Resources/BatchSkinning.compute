// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BatchSkinning
#pragma kernel BatchSkinning THREAD_GROUP_512

#ifdef THREAD_GROUP_512
#define THREAD_GROUP_SIZE 512
#else
#define THREAD_GROUP_SIZE 1024
#endif
#define THREAD_GROUP_DIVISOR 1024/THREAD_GROUP_SIZE

// We disable this warning because it assumes that we only get 16 VGPRs per thread with a threadgroup size of 1024.
// Desktop and console support 32 per thread with good occupancy. This shader uses 32 on GCN Vega.
// Todo: Reduce VGPR pressure in DQS extra boneweight sampling loops (it reads the full boneTransform from GS at once).
#pragma warning(disable: 4714)

static const uint kSkeletonLoadOpVirtual  = 0;
static const uint kSkeletonLoadOpQvvs     = 1;
static const uint kSkeletonLoadOpMatrices = 2;
static const uint kSkeletonLoadOpDqs      = 3;

// DqsFullVert is disabled because it does not work on GCN.
// Single pass requires too many VGPRs.
// Two passes back-to-back inside the vertex loop require memory barriers (which I forgot in the commented-out code)
// and the compiler generates too many VGPRs anyways.
static const uint kMeshOpCvtGsQvvsToMatReplaceGs                           = 0;
static const uint kMeshOpMulGsMatWithOffsetBindposesStoreGs                = 1;
static const uint kMeshOpMulGsMatWithBindposesStoreGs                      = 2;
static const uint kMeshOpLoadQvvsMulMatWithOffsetBindposesStoreGs          = 3;
static const uint kMeshOpLoadQvvsMulMatWithBindposesStoreGs                = 4;
static const uint kMeshOpGsTfStoreDst                                      = 5;
static const uint kMeshOpSkinMatVertInSrc                                  = 6;
static const uint kMeshOpSkinMatVertInDst                                  = 7;
static const uint kMeshOpCvtGsQvvsToDqsWithOffsetStoreDst                  = 8;
static const uint kMeshOpCvtGsQvvsToDqsWithOffsetStoreGsCopyBindposeToGs   = 9;
static const uint kMeshOpLoadCvtQvvsToDqsWithOffsetStoreGsCopyBindposeToGs = 10;
static const uint kMeshOpLoadBindposeDqsStoreGs                            = 11;
static const uint kMeshOpCvtGsQvvsToDqsWithOffsetStoreGs                   = 12;
static const uint kMeshOpCvtGsQvvsToDqsStoreGs                             = 13;
static const uint kMeshOpLoadCvtQvvsToDqsWithOffsetStoreGs                 = 14;
static const uint kMeshOpLoadCvtQvvsToDqsStoreGs                           = 15;

static const uint kMeshOpSkinDqsBindPoseVertInSrc                          = 17;
static const uint kMeshOpSkinDqsBindPoseVertInDst                          = 18;
static const uint kMeshOpSkinDqsWorldVertInDst                             = 19;


struct BoneWeight
{
    float weight;
    uint packed;
};

struct Vertex
{
    float3 position;
    float3 normal;
    float3 tangent;
};

// Can be a float3x4, a QVVS, or a DQS
struct TransformUnion
{
    float4 a;
    float4 b;
    float4 c;
};

struct Qvvs
{
    float4 rotation;
    float4 position;
    float4 stretchScale;
};

// Dual Quaternion with Scale
struct Dqs
{
    float4 r; // real
    float4 d; // dual
    float4 scale;
};

uniform ByteAddressBuffer                _boneWeights;
uniform StructuredBuffer<Vertex>         _srcVertices;
uniform StructuredBuffer<TransformUnion> _bindPoses;
uniform StructuredBuffer<Qvvs>           _skeletonQvvsTransforms;
uniform ByteAddressBuffer                _boneOffsets;

// Stride of uint4
uniform ByteAddressBuffer _metaBuffer;

uniform RWStructuredBuffer<Vertex> _dstVertices   : register(u1);
uniform RWByteAddressBuffer        _dstTransforms : register(u2);

// 8184 floats is 682 float3x4 or 744 DQ + float3.
// However, we pad out DQ + float3 to 12 floats to help GPUs
// with larger than 32-bit bank accesses.
// So we always end up with a TransformUnion of 682
groupshared TransformUnion gs_transforms[682];

uint _startOffset;

void writeBone(uint absoluteBoneIndex, TransformUnion tu)
{
    _dstTransforms.Store4(absoluteBoneIndex * 48, asuint(tu.a));
    _dstTransforms.Store4(absoluteBoneIndex * 48 + 16, asuint(tu.b));
    _dstTransforms.Store4(absoluteBoneIndex * 48 + 32, asuint(tu.c));
}

void fromQuaternion(float4 v, out float3 c0, out float3 c1, out float3 c2)
{
    float4 v2 = v + v;

    uint3 npn = uint3(0x80000000, 0x00000000, 0x80000000);
    uint3 nnp = uint3(0x80000000, 0x80000000, 0x00000000);
    uint3 pnn = uint3(0x00000000, 0x80000000, 0x80000000);
    c0 = v2.y * asfloat(asuint(v.yxw) ^ npn) - v2.z * asfloat(asuint(v.zwx) ^ pnn) + float3(1, 0, 0);
    c1 = v2.z * asfloat(asuint(v.wzy) ^ nnp) - v2.x * asfloat(asuint(v.yxw) ^ npn) + float3(0, 1, 0);
    c2 = v2.x * asfloat(asuint(v.zwx) ^ pnn) - v2.y * asfloat(asuint(v.wzy) ^ nnp) + float3(0, 0, 1);
}

float4 mulQuatQuat(float4 a, float4 b)
{
    return float4(a.wwww * b + (a.xyzx * b.wwwx + a.yzxy * b.zxyy) * float4(1, 1, 1, -1) - a.zxyz * b.yzxz);
}

float3x4 qvvsToMatrix(Qvvs qvvs)
{
    float3 scale = qvvs.stretchScale.xyz * qvvs.stretchScale.w;
    float3 c0 = 0;
    float3 c1 = 0;
    float3 c2 = 0;
    fromQuaternion(qvvs.rotation, c0, c1, c2);
    c0 *= scale.x;
    c1 *= scale.y;
    c2 *= scale.z;
    return float3x4(
        c0.x, c1.x, c2.x, qvvs.position.x,
        c0.y, c1.y, c2.y, qvvs.position.y,
        c0.z, c1.z, c2.z, qvvs.position.z
        );
}

TransformUnion matrixToTransformUnionMatrix(float3x4 mat)
{
    TransformUnion result = (TransformUnion)0;
    result.a = mat._m00_m10_m20_m01;
    result.b = mat._m11_m21_m02_m12;
    result.c = mat._m22_m03_m13_m23;
    return result;
}

float3x4 transformUnionMatrixToMatrix(TransformUnion transform)
{
    return float3x4(
        transform.a.x, transform.a.w, transform.b.z, transform.c.y,
        transform.a.y, transform.b.x, transform.b.w, transform.c.z,
        transform.a.z, transform.b.y, transform.c.x, transform.c.w
        );
}

Dqs qvvsToDqs(Qvvs qvvs)
{
    Dqs result = (Dqs)0;
    result.r = qvvs.rotation;
    result.d = 0.5 * mulQuatQuat(float4(qvvs.position.xyz, 0), qvvs.rotation);
    result.scale.xyz = qvvs.stretchScale.xyz * qvvs.stretchScale.w;
    return result;
}

TransformUnion dqsToTransformUnionDqs(Dqs dqs)
{
    TransformUnion result = (TransformUnion)0;
    result.a = dqs.r;
    result.b = dqs.d;
    result.c = float4(dqs.scale.xyz, 0);
    return result;
}

Dqs transformUnionDqsToDqs(TransformUnion transform)
{
    Dqs result = (Dqs)0;
    result.r = transform.a;
    result.d = transform.b;
    result.scale.xyz = transform.c.xyz;
    return result;
}

TransformUnion qvvsToTransformUnionQvvs(Qvvs qvvs)
{
    TransformUnion result = (TransformUnion)0;
    result.a = qvvs.rotation;
    result.b.xyz = qvvs.position.xyz;
    result.c = qvvs.stretchScale;
    return result;
}

Qvvs transformUnionQvvsToQvvs(TransformUnion transform)
{
    Qvvs result = (Qvvs)0;
    result.rotation = transform.a;
    result.position.xyz = transform.b.xyz;
    result.stretchScale = transform.c;
    return result;
}

float3x4 mul3x4(float3x4 a, float3x4 b)
{
    float4x4 x = 0.;
    x._m00 = a._m00;
    x._m10 = a._m10;
    x._m20 = a._m20;
    x._m30 = 0.;
    x._m01 = a._m01;
    x._m11 = a._m11;
    x._m21 = a._m21;
    x._m31 = 0.;
    x._m02 = a._m02;
    x._m12 = a._m12;
    x._m22 = a._m22;
    x._m32 = 0.;
    x._m03 = a._m03;
    x._m13 = a._m13;
    x._m23 = a._m23;
    x._m33 = 1.;

    float4x4 y = 0.;
    y._m00 = b._m00;
    y._m10 = b._m10;
    y._m20 = b._m20;
    y._m30 = 0.;
    y._m01 = b._m01;
    y._m11 = b._m11;
    y._m21 = b._m21;
    y._m31 = 0.;
    y._m02 = b._m02;
    y._m12 = b._m12;
    y._m22 = b._m22;
    y._m32 = 0.;
    y._m03 = b._m03;
    y._m13 = b._m13;
    y._m23 = b._m23;
    y._m33 = 1.;

    float4x4 r = mul(x, y);

    float3x4 result = 0.;
    result._m00 = r._m00;
    result._m10 = r._m10;
    result._m20 = r._m20;

    result._m01 = r._m01;
    result._m11 = r._m11;
    result._m21 = r._m21;

    result._m02 = r._m02;
    result._m12 = r._m12;
    result._m22 = r._m22;

    result._m03 = r._m03;
    result._m13 = r._m13;
    result._m23 = r._m23;

    return result;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BatchSkinning(uint threadId : SV_GroupIndex, uint3 groupIds : SV_GroupID)
{
    const uint groupId = groupIds.x;
    const uint4 skeletonCommands = _metaBuffer.Load4((groupId + _startOffset) * 16);

    const uint skeletonCount = skeletonCommands.x & 0xffff;
    const uint skeletonOperation = skeletonCommands.x >> 16;
    const uint skeletonTransformStartIndex = skeletonCommands.y;
    const uint meshCommandsStartIndex = skeletonCommands.z;
    const uint meshCommandsCount = skeletonCommands.w;

    if (skeletonOperation == kSkeletonLoadOpQvvs)
    {
        // Load the skeleton into groupshared as Qvvs
        for (uint i = threadId; i < skeletonCount; i += THREAD_GROUP_SIZE)
        {
            gs_transforms[i] = qvvsToTransformUnionQvvs(_skeletonQvvsTransforms[i + skeletonTransformStartIndex]);
        }
        GroupMemoryBarrierWithGroupSync();
    }
    if (skeletonOperation == kSkeletonLoadOpMatrices)
    {
        // Load the skeleton into groupshared as Matrices
        for (uint i = threadId; i < skeletonCount; i += THREAD_GROUP_SIZE)
        {
            float3x4 mat = qvvsToMatrix(_skeletonQvvsTransforms[i + skeletonTransformStartIndex]);
            gs_transforms[i] = matrixToTransformUnionMatrix(mat);
        }
    }
    if (skeletonOperation == kSkeletonLoadOpDqs)
    {
        // Load the skeleton into groupshared as DQS
        for (uint i = threadId; i < skeletonCount; i += THREAD_GROUP_SIZE)
        {
            Dqs dqs = qvvsToDqs(_skeletonQvvsTransforms[i + skeletonTransformStartIndex]);
            gs_transforms[i] = dqsToTransformUnionDqs(dqs);
        }
    }

    for (uint meshCommandIter = 0; meshCommandIter < meshCommandsCount; meshCommandIter++)
    {
        const uint4 meshCommand = _metaBuffer.Load4((meshCommandsStartIndex + meshCommandIter) * 16);
        const uint meshBonesCount = meshCommand.x & 0xffff;
        const uint meshOperation = (meshCommand.x >> 16) & 0xff;
        const uint meshFlags = meshCommand.x >> 24;
        const uint meshBindposesStart = meshCommand.y;
        const uint meshBoneOffsetsStart = meshCommand.z;
        const uint dstStart = meshCommand.w;

        const uint meshVerticesStart = meshCommand.y;
        const uint meshWeightsStart = meshCommand.z;

        const uint useSkeletonCountAsGsBaseAddress = (meshFlags & 0x1) != 0;

        if (meshOperation == kMeshOpCvtGsQvvsToMatReplaceGs)
        {
            // Convert skeleton Qvvs in groupshared to skeleton Matrices and overwrite in groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                Qvvs qvvs = transformUnionQvvsToQvvs(gs_transforms[i]);
                float3x4 mat = qvvsToMatrix(qvvs);
                gs_transforms[i] = matrixToTransformUnionMatrix(mat);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpMulGsMatWithOffsetBindposesStoreGs)
        {
            // Compute Matrices with skeleton Matrices in groupshared and append to groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                if ((i & 0x1) != 0)
                    boneOffset = boneOffset >> 16;
                boneOffset = boneOffset & 0x7fff;

                float3x4 bindpose = transformUnionMatrixToMatrix(_bindPoses[meshBindposesStart + i]);
                float3x4 boneMat = transformUnionMatrixToMatrix(gs_transforms[boneOffset]);
                float3x4 mat = mul3x4(boneMat, bindpose);
                gs_transforms[skeletonCount + i] = matrixToTransformUnionMatrix(mat);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpMulGsMatWithBindposesStoreGs)
        {
            // Compute Matrices with pre-offset skeleton Matrices in groupshared and append to groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                // For some reason, we have to make loading from gs unpredictable to get the compiler to do something smart.
                uint boneOffset = i;
                if (i >= 682)
                {
                    boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                    if ((i & 0x1) != 0)
                        boneOffset = boneOffset >> 16;
                }
                boneOffset = boneOffset & 0x7fff;

                float3x4 bindpose = transformUnionMatrixToMatrix(_bindPoses[meshBindposesStart + i]);
                float3x4 boneMat = transformUnionMatrixToMatrix(gs_transforms[boneOffset]);
                float3x4 mat = mul3x4(boneMat, bindpose);
                gs_transforms[skeletonCount + i] = matrixToTransformUnionMatrix(mat);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadQvvsMulMatWithOffsetBindposesStoreGs)
        {
            // Compute Matrices with skeleton Matrices in memory and write to groupshared.
            GroupMemoryBarrierWithGroupSync();
            {
                for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
                {
                    gs_transforms[i] = _bindPoses[meshBindposesStart + i];
                }
            }
            GroupMemoryBarrierWithGroupSync();
            {
                for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
                {
                    uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                    if ((i & 0x1) != 0)
                        boneOffset = boneOffset >> 16;
                    boneOffset = boneOffset & 0x7fff;

                    Qvvs qvvs = _skeletonQvvsTransforms[boneOffset + skeletonTransformStartIndex];
                    float3x4 boneMat = qvvsToMatrix(qvvs);

                    float3 temp = 0;
                    temp.x = boneMat._m00 * gs_transforms[i].a.x + boneMat._m01 * gs_transforms[i].a.y + boneMat._m02 * gs_transforms[i].a.z;
                    temp.y = boneMat._m10 * gs_transforms[i].a.x + boneMat._m11 * gs_transforms[i].a.y + boneMat._m12 * gs_transforms[i].a.z;
                    temp.z = boneMat._m20 * gs_transforms[i].a.x + boneMat._m21 * gs_transforms[i].a.y + boneMat._m22 * gs_transforms[i].a.z;
                    gs_transforms[i].a.xyz = temp;
                    temp.x = boneMat._m00 * gs_transforms[i].a.w + boneMat._m01 * gs_transforms[i].b.x + boneMat._m02 * gs_transforms[i].b.y;
                    temp.y = boneMat._m10 * gs_transforms[i].a.w + boneMat._m11 * gs_transforms[i].b.x + boneMat._m12 * gs_transforms[i].b.y;
                    temp.z = boneMat._m20 * gs_transforms[i].a.w + boneMat._m21 * gs_transforms[i].b.x + boneMat._m22 * gs_transforms[i].b.y;
                    gs_transforms[i].a.w = temp.x;
                    gs_transforms[i].b.xy = temp.yz;
                    temp.x = boneMat._m00 * gs_transforms[i].b.z + boneMat._m01 * gs_transforms[i].b.w + boneMat._m02 * gs_transforms[i].c.x;
                    temp.y = boneMat._m10 * gs_transforms[i].b.z + boneMat._m11 * gs_transforms[i].b.w + boneMat._m12 * gs_transforms[i].c.x;
                    temp.z = boneMat._m20 * gs_transforms[i].b.z + boneMat._m21 * gs_transforms[i].b.w + boneMat._m22 * gs_transforms[i].c.x;
                    gs_transforms[i].b.zw = temp.xy;
                    gs_transforms[i].c.x = temp.z;
                    temp.x = boneMat._m00 * gs_transforms[i].c.y + boneMat._m01 * gs_transforms[i].c.z + boneMat._m02 * gs_transforms[i].c.w + boneMat._m03;
                    temp.y = boneMat._m10 * gs_transforms[i].c.y + boneMat._m11 * gs_transforms[i].c.z + boneMat._m12 * gs_transforms[i].c.w + boneMat._m13;
                    temp.z = boneMat._m20 * gs_transforms[i].c.y + boneMat._m21 * gs_transforms[i].c.z + boneMat._m22 * gs_transforms[i].c.w + boneMat._m23;
                    gs_transforms[i].c.yzw = temp;
                }
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadQvvsMulMatWithBindposesStoreGs)
        {
            // Compute Matrices with pre-offset skeleton Matrices in memory and write to groupshared.
            GroupMemoryBarrierWithGroupSync();
            {
                for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
                {
                    gs_transforms[i] = _bindPoses[meshBindposesStart + i];
                }
            }
            GroupMemoryBarrierWithGroupSync();
            {
                for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
                {
                    Qvvs qvvs = _skeletonQvvsTransforms[i + skeletonTransformStartIndex];
                    float3x4 boneMat = qvvsToMatrix(qvvs);

                    float3 temp = 0;
                    temp.x = boneMat._m00 * gs_transforms[i].a.x + boneMat._m01 * gs_transforms[i].a.y + boneMat._m02 * gs_transforms[i].a.z;
                    temp.y = boneMat._m10 * gs_transforms[i].a.x + boneMat._m11 * gs_transforms[i].a.y + boneMat._m12 * gs_transforms[i].a.z;
                    temp.z = boneMat._m20 * gs_transforms[i].a.x + boneMat._m21 * gs_transforms[i].a.y + boneMat._m22 * gs_transforms[i].a.z;
                    gs_transforms[i].a.xyz = temp;
                    temp.x = boneMat._m00 * gs_transforms[i].a.w + boneMat._m01 * gs_transforms[i].b.x + boneMat._m02 * gs_transforms[i].b.y;
                    temp.y = boneMat._m10 * gs_transforms[i].a.w + boneMat._m11 * gs_transforms[i].b.x + boneMat._m12 * gs_transforms[i].b.y;
                    temp.z = boneMat._m20 * gs_transforms[i].a.w + boneMat._m21 * gs_transforms[i].b.x + boneMat._m22 * gs_transforms[i].b.y;
                    gs_transforms[i].a.w = temp.x;
                    gs_transforms[i].b.xy = temp.yz;
                    temp.x = boneMat._m00 * gs_transforms[i].b.z + boneMat._m01 * gs_transforms[i].b.w + boneMat._m02 * gs_transforms[i].c.x;
                    temp.y = boneMat._m10 * gs_transforms[i].b.z + boneMat._m11 * gs_transforms[i].b.w + boneMat._m12 * gs_transforms[i].c.x;
                    temp.z = boneMat._m20 * gs_transforms[i].b.z + boneMat._m21 * gs_transforms[i].b.w + boneMat._m22 * gs_transforms[i].c.x;
                    gs_transforms[i].b.zw = temp.xy;
                    gs_transforms[i].c.x = temp.z;
                    temp.x = boneMat._m00 * gs_transforms[i].c.y + boneMat._m01 * gs_transforms[i].c.z + boneMat._m02 * gs_transforms[i].c.w + boneMat._m03;
                    temp.y = boneMat._m10 * gs_transforms[i].c.y + boneMat._m11 * gs_transforms[i].c.z + boneMat._m12 * gs_transforms[i].c.w + boneMat._m13;
                    temp.z = boneMat._m20 * gs_transforms[i].c.y + boneMat._m21 * gs_transforms[i].c.z + boneMat._m22 * gs_transforms[i].c.w + boneMat._m23;
                    gs_transforms[i].c.yzw = temp;
                }
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpGsTfStoreDst)
        {
            // Copy Matrices in groupshared to dst.
            uint offset = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                writeBone(dstStart + i, gs_transforms[offset + i]);
            }
        }
        else if (meshOperation == kMeshOpSkinMatVertInSrc)
        {
            // Skin vertices using matrices in groupshared memory and vertices from source memory.
            const uint skeletonOffsetInGs = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            const uint meshVerticesCount = _boneWeights.Load(meshWeightsStart * 8);

            uint currentWeightBatchStart = meshWeightsStart;
            uint nextWeightBatchStart = meshWeightsStart;

            uint vertexIndexBase = 0;
            for (vertexIndexBase = 0; vertexIndexBase + 1023 < meshVerticesCount; vertexIndexBase += 1024)
            {
                nextWeightBatchStart += _boneWeights.Load(currentWeightBatchStart * 8 + 4);
                currentWeightBatchStart++;

                [unroll]
                for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    float3x4 deform = 0;

                    do
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        float3x4 skinMatrix = transformUnionMatrixToMatrix(gs_transforms[boneIndex + skeletonOffsetInGs]);

                        deform += skinMatrix * weight;
                    } while (!isEnd);

                    Vertex dstVertex = (Vertex)0;
                    Vertex vertex = _srcVertices[meshVerticesStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE];
                    dstVertex.position = mul(deform, float4(vertex.position, 1));
                    dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                    dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                    _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                }

                currentWeightBatchStart = nextWeightBatchStart;
            }

            currentWeightBatchStart++;
            [unroll]
            for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
            {
                if (vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE < meshVerticesCount)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    float3x4 deform = 0;

                    do
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        float3x4 skinMatrix = transformUnionMatrixToMatrix(gs_transforms[boneIndex + skeletonOffsetInGs]);

                        deform += skinMatrix * weight;
                    } while (!isEnd);

                    Vertex dstVertex = (Vertex)0;
                    Vertex vertex = _srcVertices[meshVerticesStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE];
                    dstVertex.position = mul(deform, float4(vertex.position, 1));
                    dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                    dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                    _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                }
            }
        }
        else if (meshOperation == kMeshOpSkinMatVertInDst)
        {
            // Skin vertices using matrices in groupshared memory and vertices from destination memory.
            const uint skeletonOffsetInGs = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            const uint meshVerticesCount = _boneWeights.Load(meshWeightsStart * 8);

            uint currentWeightBatchStart = meshWeightsStart;
            uint nextWeightBatchStart = meshWeightsStart;

            uint vertexIndexBase = 0;
            for (vertexIndexBase = 0; vertexIndexBase + 1023 < meshVerticesCount; vertexIndexBase += 1024)
            {
                nextWeightBatchStart += _boneWeights.Load(currentWeightBatchStart * 8 + 4);
                currentWeightBatchStart++;

                [unroll]
                for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    float3x4 deform = 0;

                    do
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        float3x4 skinMatrix = transformUnionMatrixToMatrix(gs_transforms[boneIndex + skeletonOffsetInGs]);

                        deform += skinMatrix * weight;
                    } while (!isEnd);

                    Vertex dstVertex = (Vertex)0;
                    Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE];
                    dstVertex.position = mul(deform, float4(vertex.position, 1));
                    dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                    dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                    _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                }

                currentWeightBatchStart = nextWeightBatchStart;
            }

            currentWeightBatchStart++;
            [unroll]
            for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
            {
                if (vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE < meshVerticesCount)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    float3x4 deform = 0;

                    do
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        float3x4 skinMatrix = transformUnionMatrixToMatrix(gs_transforms[boneIndex + skeletonOffsetInGs]);

                        deform += skinMatrix * weight;
                    } while (!isEnd);

                    Vertex dstVertex = (Vertex)0;
                    Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE];
                    dstVertex.position = mul(deform, float4(vertex.position, 1));
                    dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                    dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                    _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                }
            }
        }
        else if (meshOperation == kMeshOpCvtGsQvvsToDqsWithOffsetStoreDst)
        {
            // Compute World Dual Quaternions with skeleton Qvvs in groupshared and write out to dst.
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                if ((i & 0x1) != 0)
                    boneOffset = boneOffset >> 16;
                boneOffset = boneOffset & 0x7fff;

                Qvvs boneQvvs = transformUnionQvvsToQvvs(gs_transforms[boneOffset]);
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We only write the world DQS because Dual-Quaternion skinning requires separated bindposes and
                // world DQS in our implementation.
                writeBone(dstStart + i, dqsToTransformUnionDqs(boneDqs));
            }
        }
        else if (meshOperation == kMeshOpCvtGsQvvsToDqsWithOffsetStoreGsCopyBindposeToGs)
        {
            // Compute World Dual Quaternions with skeleton Qvvs in groupshared and append to groupshared.
            // Also append mesh bindpose Dual Quaternions into groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                // We write the bindpose towards the end of groupshared.
                gs_transforms[skeletonCount + meshBonesCount + i] = _bindPoses[meshBindposesStart + i];

                uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                if ((i & 0x1) != 0)
                    boneOffset = boneOffset >> 16;
                boneOffset = boneOffset & 0x7fff;

                Qvvs boneQvvs = transformUnionQvvsToQvvs(gs_transforms[boneOffset]);
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We write the world DQS in the middle part of groupshared.
                gs_transforms[skeletonCount + i] = dqsToTransformUnionDqs(boneDqs);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadCvtQvvsToDqsWithOffsetStoreGsCopyBindposeToGs)
        {
            // Compute World Dual Quaternions with pre-offset skeleton in memory and write to groupshared.
            // Also append mesh bindpose Dual Quaternions into groupshared.
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                // We write the bindpose in the second part of groupshared
                gs_transforms[meshBonesCount + i] = _bindPoses[meshBindposesStart + i];

                Qvvs boneQvvs = _skeletonQvvsTransforms[skeletonTransformStartIndex + i];
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We write the world DQS in the first part of groupshared.
                gs_transforms[i] = dqsToTransformUnionDqs(boneDqs);

            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadBindposeDqsStoreGs)
        {
            // Load Bindpose Dual Quaternions and append to groupshared after skeleton bones if any.
            GroupMemoryBarrierWithGroupSync();
            uint offset = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                gs_transforms[offset + i] = _bindPoses[meshBindposesStart + i];
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpCvtGsQvvsToDqsWithOffsetStoreGs)
        {
            // Compute World Dual Quaternions with skeleton Qvvs in groupshared and append to groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                if ((i & 0x1) != 0)
                    boneOffset = boneOffset >> 16;
                boneOffset = boneOffset & 0x7fff;

                Qvvs boneQvvs = transformUnionQvvsToQvvs(gs_transforms[boneOffset]);
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We write the world DQS in the middle part of groupshared.
                gs_transforms[skeletonCount + i] = dqsToTransformUnionDqs(boneDqs);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpCvtGsQvvsToDqsStoreGs)
        {
            // Compute World Dual Quaternions with skeleton Qvvs in groupshared and append to groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                Qvvs boneQvvs = transformUnionQvvsToQvvs(gs_transforms[i]);
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We write the world DQS in the middle part of groupshared.
                gs_transforms[skeletonCount + i] = dqsToTransformUnionDqs(boneDqs);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadCvtQvvsToDqsWithOffsetStoreGs)
        {
            // Compute World Dual Quaternions with skeleton in memory and write to groupshared.
            GroupMemoryBarrierWithGroupSync();
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                uint boneOffset = _boneOffsets.Load(((meshBoneOffsetsStart + i) * 2) & 0xfffffffc);
                if ((i & 0x1) != 0)
                    boneOffset = boneOffset >> 16;
                boneOffset = boneOffset & 0x7fff;

                Qvvs boneQvvs = _skeletonQvvsTransforms[skeletonTransformStartIndex + boneOffset];
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                // We write the world DQS in the first part of groupshared.
                gs_transforms[i] = dqsToTransformUnionDqs(boneDqs);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpLoadCvtQvvsToDqsStoreGs)
        {
            // Compute World Dual Quaternions with pre-offset skeleton in memory and write to groupshared.
            for (uint i = threadId; i < meshBonesCount; i += THREAD_GROUP_SIZE)
            {
                Qvvs boneQvvs = _skeletonQvvsTransforms[skeletonTransformStartIndex + i];
                Dqs boneDqs = qvvsToDqs(boneQvvs);
                gs_transforms[i] = dqsToTransformUnionDqs(boneDqs);
            }
            GroupMemoryBarrierWithGroupSync();
        }
        else if (meshOperation == kMeshOpSkinDqsBindPoseVertInSrc)
        {
            // Skin vertices using bindpose Dual Quaternions in groupshared memory and vertices from source memory. (Part 1 / 2)
            const uint skeletonOffsetInGs = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            const uint meshVerticesCount = _boneWeights.Load(meshWeightsStart * 8);

            uint currentWeightBatchStart = meshWeightsStart;
            uint nextWeightBatchStart = meshWeightsStart;

            uint vertexIndexBase = 0;
            for (vertexIndexBase = 0; vertexIndexBase + 1023 < meshVerticesCount; vertexIndexBase += 1024)
            {
                nextWeightBatchStart += _boneWeights.Load(currentWeightBatchStart * 8 + 4);
                currentWeightBatchStart++;

                [unroll]
                for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;

                    bool isEnd = false;
                    //float3x4 deform = 0;
                    float4 bindposeReal = 0;
                    float4 bindposeDual = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                    }

                    {
                        // Todo: Deform via DQS directly?
                        float mag = length(bindposeReal);
                        bindposeReal /= mag;
                        bindposeDual /= mag;

                        Qvvs bpQvvs = (Qvvs)0;
                        bpQvvs.rotation = bindposeReal;
                        bindposeReal.xyz = -bindposeReal.xyz;
                        bpQvvs.position.xyz = mulQuatQuat(2 * bindposeDual, bindposeReal).xyz;
                        bpQvvs.stretchScale = float4(1, 1, 1, 1);

                        float3x4 deform = qvvsToMatrix(bpQvvs);
                        float3x4 scale = float3x4(
                            localScale.x, 0, 0, 0,
                            0, localScale.y, 0, 0,
                            0, 0, localScale.z, 0
                            );
                        deform = mul3x4(scale, deform);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _srcVertices[meshVerticesStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }

                currentWeightBatchStart = nextWeightBatchStart;
            }

            currentWeightBatchStart++;
            [unroll]
            for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
            {
                if (vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE < meshVerticesCount)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    //float3x4 deform = 0;
                    float4 bindposeReal = 0;
                    float4 bindposeDual = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                    }

                    {
                        // Todo: Deform via DQS directly?
                        float mag = length(bindposeReal);
                        bindposeReal /= mag;
                        bindposeDual /= mag;

                        Qvvs bpQvvs = (Qvvs)0;
                        bpQvvs.rotation = bindposeReal;
                        bindposeReal.xyz = -bindposeReal.xyz;
                        bpQvvs.position.xyz = mulQuatQuat(2 * bindposeDual, bindposeReal).xyz;
                        bpQvvs.stretchScale = float4(1, 1, 1, 1);

                        float3x4 deform = qvvsToMatrix(bpQvvs);
                        float3x4 scale = float3x4(
                            localScale.x, 0, 0, 0,
                            0, localScale.y, 0, 0,
                            0, 0, localScale.z, 0
                            );
                        deform = mul3x4(scale, deform);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _srcVertices[meshVerticesStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }
            }
        }
        else if (meshOperation == kMeshOpSkinDqsBindPoseVertInDst)
        {
            // Skin vertices using bindpose Dual Quaternions in groupshared memory and vertices from destination memory. (Part 1 / 2)
            const uint skeletonOffsetInGs = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            const uint meshVerticesCount = _boneWeights.Load(meshWeightsStart * 8);

            DeviceMemoryBarrierWithGroupSync();

            uint currentWeightBatchStart = meshWeightsStart;
            uint nextWeightBatchStart = meshWeightsStart;

            uint vertexIndexBase = 0;
            for (vertexIndexBase = 0; vertexIndexBase + 1023 < meshVerticesCount; vertexIndexBase += 1024)
            {
                nextWeightBatchStart += _boneWeights.Load(currentWeightBatchStart * 8 + 4);
                currentWeightBatchStart++;

                [unroll]
                for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;

                    bool isEnd = false;
                    //float3x4 deform = 0;
                    float4 bindposeReal = 0;
                    float4 bindposeDual = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                    }

                    {
                        // Todo: Deform via DQS directly?
                        float mag = length(bindposeReal);
                        bindposeReal /= mag;
                        bindposeDual /= mag;

                        Qvvs bpQvvs = (Qvvs)0;
                        bpQvvs.rotation = bindposeReal;
                        bindposeReal.xyz = -bindposeReal.xyz;
                        bpQvvs.position.xyz = mulQuatQuat(2 * bindposeDual, bindposeReal).xyz;
                        bpQvvs.stretchScale = float4(1, 1, 1, 1);

                        float3x4 deform = qvvsToMatrix(bpQvvs);
                        float3x4 scale = float3x4(
                            localScale.x, 0, 0, 0,
                            0, localScale.y, 0, 0,
                            0, 0, localScale.z, 0
                            );
                        deform = mul3x4(scale, deform);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }

                currentWeightBatchStart = nextWeightBatchStart;
            }

            currentWeightBatchStart++;
            [unroll]
            for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
            {
                if (vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE < meshVerticesCount)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    //float3x4 deform = 0;
                    float4 bindposeReal = 0;
                    float4 bindposeDual = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        bindposeReal += dqs.r * weight;
                        bindposeDual += dqs.d * weight;
                        localScale += dqs.scale.xyz * weight;
                    }

                    {
                        // Todo: Deform via DQS directly?
                        float mag = length(bindposeReal);
                        bindposeReal /= mag;
                        bindposeDual /= mag;

                        Qvvs bpQvvs = (Qvvs)0;
                        bpQvvs.rotation = bindposeReal;
                        bindposeReal.xyz = -bindposeReal.xyz;
                        bpQvvs.position.xyz = mulQuatQuat(2 * bindposeDual, bindposeReal).xyz;
                        bpQvvs.stretchScale = float4(1, 1, 1, 1);

                        float3x4 deform = qvvsToMatrix(bpQvvs);
                        float3x4 scale = float3x4(
                            localScale.x, 0, 0, 0,
                            0, localScale.y, 0, 0,
                            0, 0, localScale.z, 0
                            );
                        deform = mul3x4(scale, deform);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }
            }
        }
        else if (meshOperation == kMeshOpSkinDqsWorldVertInDst)
        {
            // Skin vertices using World Dual Quaternions in groupshared memory and vertices from destination memory. (Part 2 / 2)
            const uint skeletonOffsetInGs = useSkeletonCountAsGsBaseAddress ? skeletonCount : 0;
            const uint meshVerticesCount = _boneWeights.Load(meshWeightsStart * 8);

            uint currentWeightBatchStart = meshWeightsStart;
            uint nextWeightBatchStart = meshWeightsStart;

            uint vertexIndexBase = 0;
            for (vertexIndexBase = 0; vertexIndexBase + 1023 < meshVerticesCount; vertexIndexBase += 1024)
            {
                nextWeightBatchStart += _boneWeights.Load(currentWeightBatchStart * 8 + 4);
                currentWeightBatchStart++;

                [unroll]
                for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;

                    bool isEnd = false;
                    //float3x4 deform = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    float4 worldReal = 0;
                    float4 worldDual = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        localScale += dqs.scale.xyz * weight;
                        worldReal += dqs.r * weight;
                        worldDual += dqs.d * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        localScale += dqs.scale.xyz * weight;
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        worldReal += dqs.r * weight;
                        worldDual += dqs.d * weight;
                    }

                    {
                        float mag = length(worldReal);
                        worldReal /= mag;
                        worldDual /= mag;

                        Qvvs worldQvvs = (Qvvs)0;
                        worldQvvs.rotation = worldReal;
                        worldReal.xyz = -worldReal.xyz;
                        worldQvvs.position.xyz = mulQuatQuat(2 * worldDual, worldReal).xyz;
                        worldQvvs.stretchScale = float4(localScale, 1);

                        float3x4 deform = qvvsToMatrix(worldQvvs);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }

                currentWeightBatchStart = nextWeightBatchStart;
            }

            currentWeightBatchStart++;
            [unroll]
            for (uint inner = 0; inner < THREAD_GROUP_DIVISOR; inner++)
            {
                if (vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE < meshVerticesCount)
                {
                    uint nextWeightIndex = currentWeightBatchStart + threadId + inner * THREAD_GROUP_SIZE;
                    bool isEnd = false;
                    //float3x4 deform = 0;

                    float3 localScale = 0;
                    float4 firstBoneRot = 0;

                    float4 worldReal = 0;
                    float4 worldDual = 0;

                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        localScale += dqs.scale.xyz * weight;
                        worldReal += dqs.r * weight;
                        worldDual += dqs.d * weight;
                        firstBoneRot = dqs.r;
                    }

                    while (!isEnd)
                    {
                        uint2 temp = _boneWeights.Load2(nextWeightIndex * 8);
                        BoneWeight boneWeight = (BoneWeight)0;
                        boneWeight.weight = asfloat(temp.x);
                        boneWeight.packed = temp.y;
                        float weight = boneWeight.weight;
                        isEnd = weight < 0.;
                        weight = abs(weight);
                        uint boneIndex = boneWeight.packed & 0x7fff;
                        nextWeightIndex += boneWeight.packed >> 22;
                        nextWeightIndex++;

                        Dqs dqs = transformUnionDqsToDqs(gs_transforms[skeletonOffsetInGs + boneIndex]);
                        localScale += dqs.scale.xyz * weight;
                        if (dot(dqs.r, firstBoneRot) < 0)
                            weight = -weight;
                        worldReal += dqs.r * weight;
                        worldDual += dqs.d * weight;
                    }

                    {
                        float mag = length(worldReal);
                        worldReal /= mag;
                        worldDual /= mag;

                        Qvvs worldQvvs = (Qvvs)0;
                        worldQvvs.rotation = worldReal;
                        worldReal.xyz = -worldReal.xyz;
                        worldQvvs.position.xyz = mulQuatQuat(2 * worldDual, worldReal).xyz;
                        worldQvvs.stretchScale = float4(localScale, 1);

                        float3x4 deform = qvvsToMatrix(worldQvvs);

                        // This forces the load to be deferred until after deform is computed, saving VGPRs
                        uint cancel = any(deform) ? 1 : 0;

                        Vertex dstVertex = (Vertex)0;
                        Vertex vertex = _dstVertices[dstStart + vertexIndexBase + threadId * cancel + inner * THREAD_GROUP_SIZE];
                        dstVertex.position = mul(deform, float4(vertex.position, 1));
                        dstVertex.normal = mul(deform, float4(vertex.normal, 0));
                        dstVertex.tangent = mul(deform, float4(vertex.tangent, 0));

                        _dstVertices[dstStart + vertexIndexBase + threadId + inner * THREAD_GROUP_SIZE] = dstVertex;
                    }
                }
            }
        }
    }
}
